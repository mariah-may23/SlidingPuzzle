	My puzzle game is ran using two files, puzzle_game.py and puzzle_classes.py. The puzzle_classes.py file contains two classes which I used to build my game. The Tiles class is used to build the game tiles. For each instance created, the constructor makes it a turtle object with a designated picture according to the puzzle file. Other methods in this class retrieve the tiles’ positions, x or y  coordinates, and moves it’s position. The swap method allows for these tiles to switch positions. The place tile method creates a 4 x 4 game board. Based on the number of tiles in the puzzle file, new tiles for each game will be assigned to these positions. The shuffle tile method helps place the tiles into random positions for the user to unscramble. The reset method briefly moves each tile back to its true position designated in the place_tile method. Afterwards, they are placed back into the previous position. The button class is specifically for the three buttons at the bottom of the game. Similarly to the tiles class, its constructor makes each instance a turtle and gives it an image required in the parameter. Helpful methods in this class return positions, coordinates and show the button. There is also a button click method which is used to signal a button when it is clicked on screen.
	The puzzle_game.py file contains all the functions used to make the game. Included in the main are the functions needed to be called in order. Following the splash screen, name, and attempts pop_up, the puzzle file is read. All of these return values passed into the create_gameboard function which controls the majority of the game. Here, the thumbnail, moves and leaderboard, and buttons are loaded onto the screen. The tile objects are made by calling the creating multiple instances of the tile class and storing them into a dictionary. Nested inside this function is the click_handler. When the user clicks the screen, the tile clicked is found and the NSEW directions of that tile is checked. If it is near the blank, a swap is made. After each tile clicked, the positions of all tiles is compared to the true positions made by creating the instances. If they match, the player wins and their score is added to the leaderboard file. If not, they continue, provided they have more attempts left. The player is allowed to pick a new game using the load button as well as quick the game. Defensive coding is used throughout the game so that any errors that occur will be logged to the error file. 
